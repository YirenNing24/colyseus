{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import fossilDelta from 'fossil-delta';\nimport { pack, unpack } from 'msgpackr';\n\nimport { Client, Protocol, Serializer, debugPatch } from '@colyseus/core';\nimport jsonPatch from 'fast-json-patch'; // this is only used for debugging patches\n\nexport class FossilDeltaSerializer<T> implements Serializer<T> {\n  public id = 'fossil-delta';\n\n  // when a new user connects, it receives the 'previousState', which holds\n  // the last binary snapshot other users already have, therefore the patches\n  // that follow will be the same for all clients.\n  private previousState: T;\n  private previousStateEncoded: any;\n\n  private patches: any;\n\n  public reset(newState: T) {\n    this.previousState = newState;\n    this.previousStateEncoded = pack(this.previousState);\n  }\n\n  public getFullState(_?: Client) {\n    return this.previousStateEncoded;\n  }\n\n  public applyPatches(clients: Client[], previousState: T) {\n    const hasChanged = this.hasChanged(previousState);\n\n    if (hasChanged) {\n      this.patches.unshift(Protocol.ROOM_STATE_PATCH);\n\n      let numClients = clients.length;\n\n      while (numClients--) {\n        const client = clients[numClients];\n        client.enqueueRaw(this.patches);\n      }\n    }\n\n    return hasChanged;\n  }\n\n  public hasChanged(newState: T) {\n    const currentState = newState;\n    let changed: boolean = false;\n    let currentStateEncoded;\n\n    /**\n     * allow optimized state changes when using `Schema` class.\n     */\n    if (newState?.['$changes']) {// tslint:disable-line\n      if (newState['$changes'].changes.size > 0) { // tslint:disable-line\n        changed = true;\n        currentStateEncoded = pack(currentState);\n      }\n\n    } else {\n      currentStateEncoded = pack(currentState);\n      changed = !currentStateEncoded.equals(this.previousStateEncoded);\n    }\n\n    if (changed) {\n      this.patches = fossilDelta.create(this.previousStateEncoded, currentStateEncoded);\n\n      //\n      // debugging\n      //\n      if (debugPatch.enabled) {\n        debugPatch(\n          '%d bytes, %j',\n          this.patches.length,\n          jsonPatch.compare(unpack(this.previousStateEncoded), currentState),\n        );\n      }\n\n      this.previousState = currentState;\n      this.previousStateEncoded = currentStateEncoded;\n    }\n\n    return changed;\n  }\n\n}\n"],
  "mappings": "AAAA,OAAO,iBAAiB;AACxB,SAAS,MAAM,cAAc;AAE7B,SAAiB,UAAsB,kBAAkB;AACzD,OAAO,eAAe;AAEf,MAAM,sBAAkD;AAAA,EAAxD;AACL,SAAO,KAAK;AAAA;AAAA,EAUL,MAAM,UAAa;AACxB,SAAK,gBAAgB;AACrB,SAAK,uBAAuB,KAAK,KAAK,aAAa;AAAA,EACrD;AAAA,EAEO,aAAa,GAAY;AAC9B,WAAO,KAAK;AAAA,EACd;AAAA,EAEO,aAAa,SAAmB,eAAkB;AACvD,UAAM,aAAa,KAAK,WAAW,aAAa;AAEhD,QAAI,YAAY;AACd,WAAK,QAAQ,QAAQ,SAAS,gBAAgB;AAE9C,UAAI,aAAa,QAAQ;AAEzB,aAAO,cAAc;AACnB,cAAM,SAAS,QAAQ;AACvB,eAAO,WAAW,KAAK,OAAO;AAAA,MAChC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,WAAW,UAAa;AAC7B,UAAM,eAAe;AACrB,QAAI,UAAmB;AACvB,QAAI;AAKJ,QAAI,WAAW,aAAa;AAC1B,UAAI,SAAS,YAAY,QAAQ,OAAO,GAAG;AACzC,kBAAU;AACV,8BAAsB,KAAK,YAAY;AAAA,MACzC;AAAA,IAEF,OAAO;AACL,4BAAsB,KAAK,YAAY;AACvC,gBAAU,CAAC,oBAAoB,OAAO,KAAK,oBAAoB;AAAA,IACjE;AAEA,QAAI,SAAS;AACX,WAAK,UAAU,YAAY,OAAO,KAAK,sBAAsB,mBAAmB;AAKhF,UAAI,WAAW,SAAS;AACtB;AAAA,UACE;AAAA,UACA,KAAK,QAAQ;AAAA,UACb,UAAU,QAAQ,OAAO,KAAK,oBAAoB,GAAG,YAAY;AAAA,QACnE;AAAA,MACF;AAEA,WAAK,gBAAgB;AACrB,WAAK,uBAAuB;AAAA,IAC9B;AAEA,WAAO;AAAA,EACT;AAEF;",
  "names": []
}
